\part{Passer d'un mot à une fonction logique}
\label{mot_to_logic}

\section{Logique des mots}
\label{sec:mot_to_logic/logique}

\subsection{Activation de gène}
\label{subsec:mot_to_logic/logique/activation}
\par
Dans un mot, \textbf{un gène est considéré comme activé, s'il est à portée d'un promoteur de même sens que lui, sans que les deux soient séparés par un terminateur du même sens.}
\par
En d'autres termes, si le mot peut s'écrire \ANY \PF \NOTANY \GF \ANY ~avec aucun \TF ~dans \NOTANY ~(ou dans l'autre sens).
\par
On dit d'un mot avec au moins un gène activé que son \textbf{Output est activée}.\\
\exx{\PF \TR \TF \GF ~n'active pas son gène mais \PF \TR \GF \TF ~oui.}

\subsection{Mots intègres}
\label{subsec:mot_to_logic/logique/integres}
\par
L'activation d'une input d'un mot le transforme, et permet donc d'obtenir un nouveau \textbf{mot résultat} de la transformation. Pour un mot contenant $n$ inputs, il y a $2^n$ combinaisons d'activation des inputs, et donc $2^n$ mots résultats. Rappelons en effet que l'ordre d'activation des inputs est indifférent (section \ref{subsec:formalisme/proprietes/confluence}).
\par
On définit ainsi un nouveau type de mots, les \textbf{mots intègres}. Un mot est dit intègre s'il est bien formé lui, mais aussi tous les mots résultats issus de lui.\\
\exx{\PF \SF{0} \PF \SR{0} \GF ~est un mot bien formé, mais pas intègre, car si on active son input, un croisement de promoteurs apparaît \PF \UF{0} \PR \UF{0} \GF}

\subsection{Table de vérité d'un mot intègre}
\label{subsec:mot_to_logic/logique/veritas}
\par
Considérons un mot intègre. Pour chacun de ses mots résultats, on peut rechercher si l'output est activée ou non. La synthèse de ces informations nous permet alors de dresser la \textbf{table de vérité d'un mot intègre}, de laquelle on sait déduire une fonction logique sous forme normale disjonctive.

\begin{table}[!h]
\centering
\begin{tabular}{C{1.1cm} C{1.1cm} C{3.8cm} C{1.1cm} C{1.8cm}}
\toprule
\mc{2}{c}{Inputs} & \mc{1}{c}{Mot obtenu} & Output & Clause\\
A (\SF{0}) & B (\SF{1}) & & & conjonctive\\
\midrule
\rowcolor{GT1} 0 & 0 & \PF \SF{0} \SF{1} \TR \SR{1} \SF{0} \GF & \true & $\neg A \wedge \neg B$\\
\rowcolor{GT2} 0 & 1 & \PF \SF{0} \UF{1} \TF \UR{1} \SF{0} \GF & \false & $\neg A \wedge B$\\
\rowcolor{GT1} 1 & 0 & \PF \UF{0} \UF{0} \GF & \true & $A \wedge \neg B$\\
\rowcolor{GT2} 1 & 1 & \PF \UF{0} \UF{0} \GF & \true & $A \wedge B$\\
\bottomrule
\end{tabular}
\caption{\label{tab:mot_to_logic/logique/veritas}Exemple de comment passer d'un mot à une fonction logique}
\end{table}

\par
Ainsi, on peut déduire d'un mot intègre une \textbf{unique fonction logique}, selon qu'il a ou non son output activé quand on active ou non ses inputs. Ici le mot implémente $(\neg A \wedge \neg B) \vee (A \wedge \neg B) \vee (A \wedge B)$.

\subsection{Mots symétriques}
\label{subsec:mot_to_logic/logique/symetriques}
\par
Le \textbf{symétrique} d'un mot, bien formé ou non, est défini comme étant le mot obtenu en appliquant une rotation et une inversion de sens des symboles du mot d'origine.\\
\exx{\PF \TR \GF ~devient \GR \TF \PR}
\par
Un mot bien formé et son symétrique implémentent la même fonction logique.

\section{Simplification de fonctions logiques}
\label{sec:mot_to_logic/simplification}

\subsection{Description de la méthode Quine-McCluskey}
\label{subsec:mot_to_logic/simplification/mccluskey}
\par
La \textbf{méthode de Quine-McCluskey}, présentée par \bsc{E. J. McCluskey Jr.} \cite{CLUS1956}, propose une amélioration de la méthode Quine, et décrit un algorithme de détermination d'une \textbf{forme normale disjonctive minimale} d'une fonction logique.
\par
Elle part d'une forme normale disjonctive (FND), pour y appliquer méthodiquement le \textbf{principe du tiers-exclus} puis le \textbf{théorème du consensus}, par un procédé simple et intuitif.

\subsection{Simplifications grâce au principe du tiers-exclu}
\label{subsec:mot_to_logic/simplification/tiers_exclu}
\par
Pour cette méthode, on part d'une fonction logique sous FND. Dans le cadre du projet en dressant la table de vérité d'un mot, on déduit d'ailleurs directement la FND de l'étude du mot (section \ref{subsec:mot_to_logic/logique/veritas}).\\
\exx{Pour cet exemple suivi, on va prendre la FND suivante :
$$\underbrace{(\neg a \wedge \neg b \wedge c)}_1
\vee\underbrace{(\neg a \wedge b \wedge \neg c)}_2
\vee\underbrace{(\neg a \wedge b \wedge c)}_3
\vee\underbrace{(a \wedge \neg b \wedge \neg c)}_4
\vee\underbrace{(a \wedge \neg b \wedge c)}_5
\vee\underbrace{(a \wedge b \wedge \neg c)}_6$$}
\par
Appliquer le \textbf{principe du tiers-exclu} va consister à identifier des paires de clauses conjonctives différentes d'un seul littéral, pour en tirer la clause conjonctive sans cette différence, qui subsume donc les deux d'origines. On répète cette opération tant que l'on peut appliquer le principe du tiers-exclu sur les clauses conjonctives obtenus.\\

\begin{wrapfigure}{r}{7cm}
\vspace{-0.2cm}
\centering
\begin{tabular}{r|lr|l}
\toprule
\mc{2}{c}{1 littéral positif} & \mc{2}{c}{2 littéraux positifs}\\
\midrule
\rowcolor{GT1} 1 & $\neg a \wedge \neg b \wedge c$ & 3 & $\neg a \wedge b \wedge c$ \\
\rowcolor{GT2} 2 & $\neg a \wedge b \wedge \neg c$ & 5 & $a \wedge \neg b \wedge c$ \\
\rowcolor{GT1} 4 & $a \wedge \neg b \wedge \neg c$ & 6 & $a \wedge b \wedge \neg c$ \\
\bottomrule
\end{tabular}
\end{wrapfigure}

\begin{quote}\begin{mdframed}[topline=false,rightline=false,bottomline=false,backgroundcolor=gray!2]\textit{\\Exemple : Pour déterminer les clauses conjonctives différentes d'un littéral, on leur attribue un numéro et on les classe par nombre de littéraux positifs.\\}\end{mdframed}\end{quote}

\begin{wrapfigure}{r}{7cm}
\vspace{-0.2cm}
\centering
\begin{tabular}{r|lr|l}
\toprule
\rowcolor{GT1} (1,3) & $\neg a \wedge c$ & (2,6) & $b \wedge \neg c$ \\
\rowcolor{GT2} (1,5) & $\neg b \wedge c$ & (4,5) & $a \wedge \neg b$ \\
\rowcolor{GT1} (2,3) & $\neg a \wedge b$ & (4,6) & $a \wedge \neg c$ \\
\bottomrule
\end{tabular}
\end{wrapfigure}

\exx{On cherche alors les différents manières d'appliquer le principe de tiers-exclu entre les clauses conjonctives différentes d'un seul littéral positif, jusqu'à ne plus pouvoir inhiber d'autres clauses conjonctives.}

\begin{wrapfigure}{R}{0cm}
\end{wrapfigure}

\subsection{Simplifications par théorème du consensus}
\label{subsec:mot_to_logic/simplification/consensus}
\par
A cette étape, nous avons une liste de clauses conjonctives et l'on ne peut plus appliquer le principe du tiers-exclus. On va donc se servir du \textbf{théorème du consensus} pour terminer la simplification de la fonction logique. Ce théorème dit que :
$$(a \wedge b) \vee (\neg a \wedge c) \vee (b \wedge c) = (a \wedge b) \vee (\neg a \wedge c)$$
\par
L'idée est donc de chercher, dans les clauses conjonctives que l'on a obtenu à l'étape d'avant, celles dont les littéraux sont présents avec la même positivité dans d'autres clauses conjonctives, afin de les éliminer pour redondance.
\par
Cependant, en fonction de l'ordre avec lequel on le fait, on peut éliminer des clauses conjonctives différentes tout en ne perdant aucune information. C'est pour cela qu'il n'y a pas unicité de la forme minimale obtenue à la fin.\\

\begin{wrapfigure}{R}{7cm}
\vspace{0.2cm}
\centering
\begin{tabular}{r|lr|l}
\toprule
\rowcolor{GT1} \textcolor{red}{(1,3)} & $\neg a \wedge c$ & \textcolor{blue}{(2,6)} & $b \wedge \neg c$ \\
\rowcolor{GT2} (\textcolor{red}{1},\textcolor{olive}{5}) & $\neg b \wedge c$ & \textcolor{olive}{(4,5)} & $a \wedge \neg b$ \\
\rowcolor{GT1} (\textcolor{blue}{2},\textcolor{red}{3}) & $\neg a \wedge b$ & (\textcolor{olive}{4},\textcolor{blue}{6}) & $a \wedge \neg c$ \\
\bottomrule
\end{tabular}
\end{wrapfigure}

\exx{Grâce au numérotage des clauses conjonctives, on sait de quelles clauses conjonctives initiales elles proviennent. Il suffit donc très simplement de repérer celles dont la numérotation se retrouve dans d'autres. Par exemple, (1,3) est redondante car on retrouve 1 et 3 dans (1,5) et (2,3).}

\begin{wrapfigure}{R}{7cm}
\vspace{-0.4cm}
\centering
\begin{tabular}{r|lr|l}
\toprule
\rowcolor{GT1} (\textcolor{red}{1},\textcolor{blue}{3}) & $\neg a \wedge c$ & (\textcolor{blue}{2},\textcolor{olive}{6}) & $b \wedge \neg c$ \\
\rowcolor{GT2} \textcolor{red}{(1,5)} & $\neg b \wedge c$ & (\textcolor{olive}{4},\textcolor{red}{5}) & $a \wedge \neg b$ \\
\rowcolor{GT1} \textcolor{blue}{(2,3)} & $\neg a \wedge b$ & \textcolor{olive}{(4,6)} & $a \wedge \neg c$ \\
\bottomrule
\end{tabular}
\end{wrapfigure}

\exx{Comme on le voit ci-contre, l'ordre des clauses conjonctives avec lequel on recherche les redondances amène à en éliminer des différentes.}

\begin{wrapfigure}{R}{0cm}
\end{wrapfigure}

\par
Au final, chaque clause conjonctive initiale (repérée par son numéro), ne doit être représentée qu'une seule fois pour bien avoir une forme normale disjonctive minimale.\\

\exx{La première manière de trouver les redondances donne : $(\neg b \wedge c) \vee (\neg a \wedge b) \vee (a \wedge \neg c)$\\
La seconde donne : $(\neg a \wedge c) \vee (b \wedge \neg c) \vee (a \wedge \neg b)$\\
Et toutes deux sont équivalentes.}

\section{Sémantique des séquences}
\label{sec:mot_to_logic/semantique}

\subsection{Définition de la sémantique}
\label{subsec:mot_to_logic/semantique/definitions}

\par
Un mot se compose de sites entre lesquels on peut trouver, ou non, des séquences (composés uniquement de promoteurs, terminateurs, et gènes). Il existe une infinité de séquences possibles, mais toutes peuvent être décrites selon plusieurs \textbf{attributs} : c'est leur \textbf{sémantique}. La sémantique d'une séquence nous permet de décrire son comportement au sein d'un mot.

\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\begin{tabular}{*8c}
\toprule
Séquence & \gt{PF} & \gt{PR} & \gt{TF} & \gt{TR} & \gt{GF} & \gt{GR} & \gt{G}\\
\midrule
\rowcolor{GT1} \PF \GF & \true & 0 & 0 & 0 & \true & 0 & \true\\
\rowcolor{GT2} \TF \PR \GR & 0 & \true & \true & 0 & 0 & \true & 0\\
\rowcolor{GT1} \TF \PR \GR \GF & 0 & \true & \true & 0 & 0 & \true & 0\\
\bottomrule
\end{tabular}
\caption{\label{fig:mot_to_logic/semantique/definitions}Exemples de sémantiques}
\end{wrapfigure}

\par
Connaissant le rôle de chacun des symboles qui composent une séquence, on en déduit la liste des attributs qui caractérisent une séquence :

\begin{itemize}
\item Est-ce qu'elle promeut dans un sens (\textbf{PFing}) ou l'autre (\textbf{PRing}) ?
\item Est-ce qu'elle termine dans un sens (\textbf{TFing}) ou l'autre (\textbf{TRing}) ?
\item Est-ce qu'elle peut être activée dans un sens (\textbf{GFing}) ou l'autre (\textbf{GRing}) ?
\item Est-ce qu'elle active elle-même le gène (\textbf{Ging}) ?
\end{itemize}

\subsection{Equivalences sémantiques}
\label{subsec:mot_to_logic/semantique/equivalences}
\par
On pourrait dire que deux séquences sont sémantiquement équivalentes si elles ont la même sémantique. Cependant, l'attribut \textbf{Ging} est différent des autres, en ce sens que, une séquence \textbf{Ging} mise au sein d'un mot entraînera l'activation de l'output de tout le mot, quelque soit l'interprétation de ses autres attributs.\\
\exx{\SF{0} \PF \GF \SF{0} active le gène en son sein, sauf dans le cas de l'excision. Ce mot représente la fonction $\neg a$.\\
Mais \SF{0} \TF \PF \GF \SF{0} a exactement la même logique. Bien que l'attribut \textbf{TFing} de la séquence soit différent du mot d'avant, la fonction représentée est toujours $\neg a$.}
\par
Cette différenciation de \textbf{Ging} par rapport aux autres attributs rajoute une condition à la définition d'équivalence sémantique : deux séquences sont \textbf{sémantiquement équivalentes si elles possèdent la même caractérisation, ou si elles activent toutes deux le gène en leur sein.}


\subsection{Classes d'équivalence représentées}
\label{subsec:mot_to_logic/semantique/classes}
\par
\textbf{Les ensembles regroupant toutes les séquences équivalentes entre elles sont des classes d'équivalences.} Une classe d'équivalence est dite \textbf{représentée} si elle n'est pas vide, et l'union de toutes les classes d'équivalences forme l'univers des séquences.
\par
Ce qui est intéressant, c'est de remarquer que toutes les classes d'équivalences ne sont pas représentées. En effet, certaines combinaisons d'attributs sont impossibles.\\
\exx{\textbf{TFing} et \textbf{GFing} sont incompatibles, car si un\TF se trouve avant un\GF, jamais le\GF ~ne sera activé, et si le\TF se trouve après, jamais il ne servira, car s'il y a \PF ~plus tôt, il activera le\GF ~avant de rencontrer le\TF.}
\par
Pour savoir quelles classes d'équivalences sont représentées, et pour trouver leur représentant le plus simple, l'algorithme \ref{alg:mot_to_logic/semantique/classes} construit l'ensemble des séquences de sémantiques différentes, en commençant par les séquences triviales, et en veillant à éliminer les séquences mal formées.
\par
L'algorithme se termine, avec un ensemble de \textbf{26 séquences} qui sont donc les représentants les plus simples des \textbf{26 classes d'équivalences possibles}. La liste détaillée des 26 est disponible en annexe \ref{sec:annexes/classes}.\\
\exx{Les classes d'équivalences triviales, caractérisées par aucun ou un seul attribut, ont pour représentants les plus simples le mot vide ou chaque symbole seul.}

\begin{algorithm}[H]
\floatname{algorithm}{Algorithme}
\caption{Création de l'ensemble des représentants les plus simples des classes d'équivalences}\label{alg:mot_to_logic/semantique/classes}
\begin{algorithmic}
\Procedure{créerReprésentants}{}{ : ensemble des représentants les plus simples}
\State $R \gets \{\epsilon, PF, PR, TF, TR, GF, GR\}$ : ensemble \Comment{Représentants des classes d'équivalences triviales}
\State $estR?$ : booléen
\State $nouveauR$ : mot
\ForAll{$r \in R$}
\ForAll{$s \in R$}
\State $nouveauR \gets r + s$ \Comment{Pour chaque concaténation de deux représentants}
\State $estR? \gets Vrai$
\ForAll{$t \in R$} \Comment{Est-elle représentative d'une sémantique nouvelle ?}
\If{$nouveauR.estSemantiquementEquivalent(t)$}
\State $estR? \gets Faux$ \Comment{Non, donc ce n'est pas un nouveau représentant}
\State Break
\EndIf
\EndFor
\If{$estR?$ et $estBienForme(nouveauR)$} \Comment{Oui, donc c'est un nouveau représentant}
\State $R \gets R \cup \{nouveauR\}$
\EndIf
\EndFor
\EndFor
\State \textbf{Renvoyer} $R$ \Comment{Résultat en annexe \ref{sec:annexes/classes}}
\EndProcedure
\end{algorithmic}
\end{algorithm}
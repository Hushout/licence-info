
\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{color}
\usepackage{graphicx}
\usepackage{array}
\usepackage{verbatim}
\usepackage{geometry}
\usepackage{slashbox}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{pifont}
\geometry{hmargin=2cm,vmargin=2.3cm}

\definecolor{mainTitleColor}{RGB}{14, 128, 90}
\newcommand{\sectionwithcolor}[1] {{\color{mainTitleColor} \section{#1}}}
\newcommand{\subsectionwithcolor}[1] {{\color{mainTitleColor} \subsection{#1}}}
\newcommand{\subsubsectionwithcolor}[1] {{\color{mainTitleColor} \subsubsection{#1}}}



\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.75\textwidth]{logo_complet} 
	\par\vspace{1cm}
	{\scshape\LARGE Université de Montpellier \par}
	\vspace{1cm}
	{\scshape\Large Projet TER\par}
	\vspace{1.5cm}
	{\huge\bfseries Outil de Gestion d'un Emploi du Temps\par}
	\vspace{2cm}
	{\Large Thomas \textsc{Lemaître}\par}
	{\Large Bérénice \textsc{Lemoine}\par}
	{\Large Julien \textsc{Lesinski}\par}
	{\Large Olivier \textsc{Montet}\par}
	\vfill
	Supervisé par\par
	Mme Hinde \textsc{Bouziane}

	\vfill

% Bottom of the page
	{\large \today\par}
\end{titlepage}

\renewcommand*\contentsname{Sommaire}
\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\section{Introduction}

Le TER\footnote{Travaux d'Etude et de Recherche} de 2\ieme ~année de licence en informatique est un projet important permettant de découvrir des domaines que nous ne maîtrisons pas encore, ainsi que d’utiliser de manière concrète des connaissances déjà acquises.

Ce projet informatique avait pour but de mettre en place un outil de gestion d’emploi du temps, c’est-à-dire, que nous devions créer un emploi du temps sur une semaine type d’un semestre. Le projet Octempos consiste à développer un outil pour créer et afficher un emploi du temps respectant un maximum de contraintes saisies par l'utilisateur. Pour mener à bien ce projet, il a fallu être en mesure de gérer de multiples contraintes mais aussi être apte à travailler en groupe et donc à se coordonner sur la modélisation et l'implémentation du projet. Nous avons mis en place un programme en Java avec une interface graphique (réalisée grâce à Java Swing/Awt) permettant la saisie des différentes UEs\footnote{Unités d'Enseignement} ainsi que des contraintes souhaitées, et réalisant un emploi du temps qui respecte au mieux les attentes de l'utilisateur ; ceci à l’aide d’un solveur appartenant à une librairie de Java appelée « Choco ». Si le solveur trouve une solution, le programme crée une page web affichant les cours des différents groupes pour une semaine.

Lors des premières séances de travail en groupe nous avons surtout réfléchi à la modélisation du projet, c’est-à-dire, aux façons de mettre en œuvre les différentes problématiques, mais aussi à la répartition des tâches. Apprenant le Java depuis le début du semestre 2, nous avons tous dû apprendre à utiliser un langage ou un concept inconnu, nous nous sommes ainsi mis d’accord assez facilement sur la répartition des tâches, chacun choisissant la partie qui l’intéressait le plus. Toutefois, les réflexions importantes sur la répartition des différentes directions à prendre se sont faites en groupe. Afin de faciliter le partage de fichiers et le travail collaboratif, nous avons utilisé le serveur « Gît » de l'université : « GitLab ». Il est possible d’avoir accès à notre dépôt Git\footnote{Si vous souhaitez avoir accès au dépôt « Git », contactez l’un de nous quatre (Lemaître Thomas, Lemoine Bérénice, Lesinski Julien, Montet Olivier) à l’adresse mail : \texttt{prénom.nom@etu.umontpellier.fr}}. Pour le partage des fichiers, nous avons fait le choix d’utiliser l'IDE (Integrated Development Environment) « Eclipse Neon » (une version adaptée à Java) pour sa simplicité d’utilisation mais aussi pour sa bonne cohabitation avec Git. 

Ce rapport abordera d'abord le problème précis sur lequel nous avons travaillé, ainsi que les choix de conception. Ensuite, il traitera les choix de modélisation puis les outils utilisés. Finalement, il exposera l'avancement du projet et conclura sur un bref résumé du projet et des compétences que nous avons acquises.

\section{Analyse des Problèmes et Choix de Conception}

Cette partie va introduire les différentes problématiques qui ont aiguillé le projet Octempos et la façon dont nous avons choisi de répondre à celles-ci.  

\subsection{Modélisation}

La modélisation du problème a été une partie importante de notre projet. Celle-ci a mené chacun d'entre nous à exposer sa vision des choses pour ensuite trouver, ensemble, une solution qui nous semblait être la meilleure mais aussi celle que nous étions capable de réaliser. Le point sur lequel nous avons tous été d’accord était le suivant : il fallait différents objets, un objet représentant les UEs, un pour les contraintes et un autre pour les groupes. Ensuite, nous avons réfléchi aux informations nécessaires pour chacun des objets. Ainsi, il a tout d'abord fallu déterminer différents types nécessaires pour l'objet \texttt{Contrainte} (voir \hyperref[typeContrainte]{Table 1}).

\begin{table}[h]
    \centering
    \label{typeContrainte}
    \begin{tabular}{|p{0.2\textwidth}| p{0.75\textwidth}|}
        \hline
        \begin{center} \textit{Type de contrainte} \end{center}& \begin{center} \textit{Description} \end{center}\\
        \hline
        \texttt{Voulu} & Elle permet d'imposer un horaire (Jour et heure) pour une séance (TD, TP ou CM) choisi par l'utilisateur. \\ 
        \hline
        \texttt{NonVoulu} & Elle permet d'interdire une séance d'être à un horaire particulier (choisi par l'utilisateur). \\
        \hline
        \texttt{Diff} & Elle permet d'obliger deux séances (ou plus) à n'avoir pas lieu au même moment. \\ 
        \hline
        \texttt{Equi} & Elle permet de contraindre deux séances à avoir lieu au même moment. \\ 
        \hline
        \texttt{Suivi} & Elle permet de faire en sorte qu'exactement deux séances se trouvent à la suite l'une de l'autre. \\ 
        \hline
    \end{tabular}
    \caption{Les différents types de contrainte}
\end{table}


Pour l’objet \texttt{UE}, il a fallu mettre beaucoup d’attributs, tout d'abord, le nom du responsable, celui de l’UE, les nombres des différents types de cours, mais aussi les différents groupes qui composent cette unité d’enseignement, etc. La liste des éléments essentiels pour chacun des objets a ainsi été mise en place (pour plus de détails vous pouvez trouver en annexe le premier diagramme de classes que nous avons réalisé et \hyperref[diagrammeclasse]{le diagramme UML\footnote{Unified Modeling Language} final}, vous permettant de voir tous les attributs des différents objets et de voir l’évolution de notre modèle de  conception).
%olivier 
\label{model}

Par la suite, il nous a fallu établir un modèle pour exploiter ces différents objets. Un modèle est axé sur trois points. Premièrement, des variables, ensuite des contraintes sur les variables et enfin un solveur qui va résoudre toutes les contraintes en assignant des valeurs aux variables pour trouver une solution à notre problème. La variable ici choisie pour le programme Octempos est une matrice d'entiers (l'ensemble de valeurs que peuvent prendre ces entiers est compris entre 0 et le nombre de séances total). Elle est composée de trente-cinq colonnes et son nombre de lignes est égal au nombre total de sous-groupes (les sous-groupes sont des groupes indivisibles, par exemple, le groupe A et les sous-groupes A1 et A2). Le but de ce modèle est, pour chaque sous-groupe, de lui assigner un tableau de trente-cinq cases pour représenter tous les créneaux de 1h30 qu'il y a dans une semaine ($5 \textrm{ jours} \times 7 \textrm{ créneaux}$).

\begin{table}[h]
\label{matrice}
    \centering
    \begin{tabular}{|c|c|c|c|c|}
         \hline
        \backslashbox{Sous-Groupes}{Créneaux} & Lundi (8h--9h30) & Lundi (9h45--11h15) & Lundi (11h30--13h) & ...\\ 
        \hline
        A1 & 0 & 1 & 2 & ... \\ 
        \hline
        A2 & 3 & 1 & 4 & ... \\
        \hline
    \end{tabular}
    \caption{La variable \textit{matrice}}
\end{table}
 
Par exemple, la figure \hyperref[matrice]{ci-dessus} représente une matrice avec deux sous-groupes, et les entiers de 0 à 4 sont des identifiants (ID) de séances. L'ID 1 est un cours commun entre les deux sous-groupes, la valeur 0, quant à elle, ne représente aucune séance, elle est utilisée pour un horaire sans cours pour le sous-groupe.

Nous verrons, par la suite, comment les objets sont instanciés et utilisés par le modèle pour générer un emploi du temps.

\subsection{Gestion des Données et des Contraintes}

La création d’un outil de gestion d’emploi du temps nécessite de manipuler de nombreuses données (que nous appellerons ici objet) telles que les unités d’enseignement, les contraintes à respecter ou encore les groupes qu’il faudra créer selon les paramètres des UEs.

\subsubsection{Sauvegarde des données}

Une sauvegarde des données s'est avérée nécessaire afin de faciliter la saisie de celles-ci. Cette sauvegarde permet, une fois que l'utilisateur a saisi des informations, de les sauvegarder. S'il le décide, il sera en mesure de les réutiliser et de modifier ces données sans avoir à tout ressaisir. Pour mettre en place cette sauvegarde, il a fallu réfléchir à la façon de récupérer les contraintes, les unités d’enseignement et les informations sur le responsable, le nombre d’heures, etc.

Nous avons opté pour une interface permettant de saisir de nouvelles données et d'importer des données existantes. Il est possible aussi de modifier ces données si elles existent déjà. Ce qui permettra, par exemple, d'alléger les contraintes lorsque le programme n'arrive pas à fournir une solution. Afin d’enregistrer les données, nous avions le choix entre faire une base de données ou créer un fichier (semblable à un fichier de configuration). Possédant peu de connaissances sur les bases de données, nous avons préféré apprendre à gérer les flux en Java, et avons choisi de créer un fichier (vous pouvez trouver ce fichier sous le nom de \hyperref[save]{« save.txt »}). 

Le fichier a une syntaxe que nous avons définie : tout d’abord les groupes qui ont été entrés lors de la saisie avec chacun de ses sous-groupes. Ensuite, il y a le nom d’une UE, avec son responsable, les différentes séances de celle-ci et les différentes contraintes pour chacune des séances, etc. 

\subsubsection{Les Contraintes}

Une fois les données sauvegardées et récupérées, il faut les soumettre à un ensemble de contraintes pour que le solveur puisse fournir une solution.

Il est très rare de réussir à organiser un emploi du temps qui respecte toutes les contraintes, c'est pour cette raison qu'il faut en modéliser deux sortes. Les contraintes dures qui doivent toutes être satisfaites par le solveur et les contraintes molles dont le solveur essaie d'en satisfaire un maximum. En voici un descriptif dans la \hyperref[duresEtMolles]{table 3}.

\begin{table}[h!]
    \centering
    \label{duresEtMolles} 
    \begin{tabular}{|p{0.5\textwidth}| p{0.5\textwidth}|}
        \hline
        \begin{center} \textit{Contraintes Dures} \end{center}& \begin{center} \textit{Contraintes Molles} \end{center}\\
        \hline
            \begin{itemize}[label=\textbullet]
                \item Si l'une d'elles n'est pas satisfaite, aucune solution n'est trouvée par le solveur.
                \item Représente des attentes, l'utilisateur veut toutes les voir apparaître dans l'emploi du temps.
                \item Contraintes utilisées par défaut dans Octempos.
            \end{itemize}        
        & 
            \begin{itemize}[label=\textbullet]
                \item Si l'une d'elles n'est pas satisfaite, le solveur cherche une autre solution sans cette contrainte.
                \item Représente des préférences, l'utilisateur veut en avoir un maximum représentée dans l'emploi du temps.
            \end{itemize}\\ 
        \hline
        
    \end{tabular}
    \caption{Deux sortes de contrainte}
\end{table}

Citons quelques exemples pour comprendre :

\begin{itemize}[label=\textbullet]
\item On attend du programme qu'un groupe ait une pause pour manger, concrètement, il ne doit pas avoir un cours à 11h30 et à 13h15. Cette contrainte par défaut est une contrainte dure, elle ne peut pas être retirée par l'utilisateur et doit être satisfaite dans tous les cas.

\item Interdire un horaire à une séance est une contrainte dure, car si l'utilisateur l'a souhaitée, elle doit être satisfaite.

\item Une séance qui doit être suivie dans le temps par une autre séance est une contrainte molle : si l'utilisateur l'a entrée, mais qu'elle ne peut être satisfaite, alors elle n'apparaîtra pas dans la solution.
\end{itemize}

\hyperref[listContraintes]{Vous trouverez en annexe la liste de toutes les contraintes gérées par Octempos.}

\subsection{Interface Homme-Machine}

L’objectif de l’IHM\footnote{Interface Homme-Machine} est de simplifier l’utilisation de l'outil pour les utilisateurs. Nous avons pour cela décidés de créer un système de fenêtre.

\subsubsection{Visualisation et Manipulation des Données}
%\subsubsection{La Visualisation des Données}
\begin{wrapfigure}{l}{0.5\textwidth} 
    \label{brouillon}
    \centering
    \includegraphics[width=0.45\textwidth]{brouillon}
    \caption{Un schéma de la fenêtre principale}
\end{wrapfigure}

%Liste des fonctionnalités

Le but était d'avoir une synthétisation des données de l'outil dans la fenêtre, représentée à gauche sur \hyperref[brouillon]{le schéma}.

Pour afficher les groupes de base, nous avons décidé de les lister dans une autre fenêtre : la fenêtre des groupes. Les sous-groupes, en revanche, ne doivent pas être listés car ceux-ci sont gérés par l'outil uniquement.
%sont créés au besoin du programme lorsque l’utilisateur décide par exemple que des séances ne doivent contenir que des demi-groupes. 
L'utilisateur doit aussi pouvoir accéder au mode d'emploi d'Octempos, nous avons décidé, pour cela, de créer un bouton dans la fenêtre principale. Nous avons choisi que tous les boutons de la fenêtre principale soient des images plutôt que du texte. Cela peut paraître déroutant lors de la première utilisation mais fluidifie la navigation lors des utilisations suivantes. Ces images permettent ainsi à l’utilisateur de moins chercher où se trouve le bouton dont il a besoin, néanmoins, en passant sur le bouton une infobulle doit pouvoir informer de ce que fait le bouton concrètement.

Pour informer l'utilisateur des étapes de la génération de l'emploi du temps, nous avons décidé de créer une fenêtre contenant les messages affichés normalement dans la console. 

En ce qui concerne le système de fenêtre, il doit permettre notamment de modifier les données inhérentes au programme. En effet, les UEs et les contraintes (ou préférences) doivent être modifiables et supprimables via des boutons dédiés de la fenêtre principale après avoir sélectionné les éléments voulus. Les séances, en revanche, ne devaient pas pouvoir être modifiables directement, car nous avons décidé de les générer selon les paramètres de l’UE. Une autre fenêtre doit aussi permettre de modifier les groupes de base.

Nous avons choisi pour permettre à l'utilisateur de sauvegarder, de créer un bouton dans la fenêtre principale qui serait disponible uniquement quand il y aurait des données à sauvegarder.

\subsubsection{Affichage de la Solution}

Une fois qu’une solution est trouvée, il fallait un moyen pour l'afficher sous la forme d'un emploi du temps. Ce dernier représente les cinq jours de travail de la semaine et affiche l'emploi du temps de tous les groupes créés. Nous avons fait le choix de créer une solution modifiable par l'utilisateur pour permettre des modifications manuelles.
Pour cela, il a été décidé que l’emploi du temps serait renvoyé sous forme de page web contenant cinq tableaux, un par jour de travail de la semaine. Ces tableaux sont des tableaux à double entrée (semblable à la \hyperref[exedt]{Figure 2}), les lignes représentent les groupes que l’on doit afficher et les colonnes correspondent aux horaires possibles de travail. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{exemple}    
    \label{exedt}
    \caption{Exemple d'emploi du temps}
\end{figure}

\subsection{Schéma Récapitulatif des Choix de Conception}

\begin{figure}[h!!]
    \label{architecture}
    \centering
    \includegraphics[width=0.8\textwidth]{representationarchitecture}
    \caption{Représentation de l'architecture voulue}
\end{figure}

\section{Choix Technologiques et Implémentation}

Cette partie du rapport va aborder les points techniques du projet. En passant par les choix des langages et outils utilisés mais aussi par les choix d'implémentation.

\subsection{Choix et relations des fonctionnalités}

Les données ont été introduites sous forme d'objet, il était donc naturel de les implémenter dans un langage orienté objet. Connaissant le C++ et débutant en Java, notre choix s'est donc porté sur l'un d'entre eux. L'utilisation de « Choco » comme solveur de contraintes nous a dirigé sur le Java (cf. \hyperref[contrainteimpl]{3.2 Gestion des Données et des Contraintes}), plutôt qu'utiliser le C++ avec son solveur « GECODE » qui nous paraissait moins abordable. 
Les principales bibliothèques Java qui ont été utilisées sont « Choco », pour les contraintes, et « Java Swing » pour l'interface graphique. \'{E}galement, les classes (préexistantes) telles que \texttt{StringTokenizer}, \texttt{BufferedReader}, \texttt{BufferedWriter}, \texttt{FileReader} et \texttt{FileWriter} ont été essentielles à la sauvegarde et la lecture des données inscrites dans le fichier \hyperref[save]{« save.txt »}.
La \hyperref[architecture]{Figure 3} présente les points sur lesquels est centré le projet. Elle en présente quatre, mais lors de l'utilisation de l'outil, seules l'interface graphique et la page web sont visibles. Le programme affiche l'interface laissant saisir les UEs ainsi que les contraintes désirées. L'utilisateur fait ensuite le choix de sauvegarder ou non ces informations. S'il le fait, le programme gérant l'interface sauvegarde les valeurs dans un fichier \hyperref[save]{« save.txt »}, ainsi lors de la prochaine utilisation du programme, si l'utilisateur demande de récupérer la sauvegarde, le programme ira lire le fichier afin d'enregistrer les données dans le programme. Sinon, il devra ressaisir toutes les informations à la prochaine réutilisation. Une fois les données saisies ou récupérées, le programme fait appel au solveur pour générer un emploi du temps respectant un maximum de contraintes. Puis, le programme affiche l'emploi du temps dans une page web.

\subsection{Gestion des Données et des Contraintes}
\label{contrainteimpl}

\subsubsection{Implémentation de la sauvegarde des Données}

Cette partie est celle qui a été le plus souvent modifiée. Nous voulions d'abord nous en occuper dans le \texttt{main}, mais cela rendait notre code abscons. Nous avons donc choisi de créer une classe \texttt{Configuration.java}, qui gère l'écriture des données, de l'interface dans le fichier de sauvegarde (en utilisant la méthode \texttt{void LoadConfig(String nomFichier)}). Cette classe gère aussi la lecture du fichier (à l'aide de la classe \texttt{StringTokenizer} en Java) et l'enregistrement des données dans le programme (à l'aide de la méthode \texttt{boolean saveConfig(String nomFichier)}). La classe \texttt{Configuration.java} contient de nombreux accesseurs qui ont facilité l'implémentation des autres parties du projet.

\subsubsection{Modèle de Contraintes}

Nous avons précédemment souligné l'importance d'établir un modèle pour trouver une solution au problème de de gestion. Pour l'implémenter, notre choix s'est porté sur la librairie Choco. C'est une librairie Java qui fournit un grand nombre de méthodes permettant de créer des contraintes (voir annexe \autoref{Choco})

En premier lieu, il faut implémenter la variable vue dans la partie \ref{model}.

\begin{itemize}[label=\textbullet]
\item
\textit{\texttt{Model model = new Model("Emploi Du Temps");}}

Avant tout, on instancie un nouveau \texttt{Model} nommé « Emploi Du Temps » (\texttt{Model} étant un objet de Choco).

\item
\textit{\texttt{IntVar[][] matriceDuTemps = model.intVarMatrix("", nbg, 35, 0, n);}}

La variable est donc une matrice de \texttt{IntVar} (une variable spécifique à Choco qui s'assimile à l'entier (\texttt{int}) de Java) créée grâce à la méthode :\\ \texttt{intVarMatrix(String nom,int nbLisgnes,int nbColonnes,int valMin,int valMax)}.
Ces \texttt{IntVar}s vont pouvoir, lors de l'exécution, prendre un entier entre 0 et n où n est le nombre de séances total.
\end{itemize}

En second lieu, il faut établir un ensemble de contraintes sur la variable, \hyperref[listContraintes]{vous pouvez retrouvez l'ensemble des contraintes en annexe}. \'Etudions quelques contraintes pour comprendre :
\begin{itemize}[label=\textbullet]
\item 
\textit{\texttt{model.count(0, onze-treize, model.intVar(1,2)).post();}}

Cette contrainte permet à un groupe d'avoir une pause pour manger, concrètement, il ne doit avoir qu'un seul cours de 11h30 à 15h.
La méthode \texttt{count(int valeur, IntVar[] Tableau, IntVar limite)} permet par ailleurs de tester si l'entier 0 (aucun cours), se trouve entre 1 à 2 fois dans le tableau \texttt{onze-treize} (qui possède les deux créneaux possibles de repas d'un groupe pour un jour).

\item
\textit{\texttt{model.arithm(matriceDuTemps[IdsousGroupe][Obli],"=",seance.getId()).post();}}

Ici, on impose à un groupe d'avoir une séance donnée à un horaire précis. \\La méthode \texttt{arithm(IntVar horaire, String opérateur, int identifiant)} oblige le créneau d'un groupe (position dans la matrice \texttt{[ID du groupe][horaire de l'obligation]}) à posséder cette séance (donc que le \texttt{IntVar} soit égal à l'identifiant du groupe).

\item La dernière contrainte est plus compliquée, elle doit faire en sorte que deux séances se suivent dans le temps.

Cependant, c'est une contrainte molle, donc il ne faut pas seulement demander au solveur de la résoudre, mais aussi de vérifier qu'elle est satisfiable. \`A la place du \texttt{.post()} qu'on utilise pour les contraintes dures, on utilise la méthode \texttt{.reify()}. Cette méthode a la particularité de renvoyer \texttt{true} si la contrainte est satisfiable, sinon elle renvoie \texttt{false} et demande au solveur de l'oublier. Pour satisfaire le plus grand nombre de préférences, il suffit de récupérer le nombre de préférences satisfiables et de le maximiser.
\end{itemize}

Le solveur va par la suite résoudre toutes ces contraintes pour assigner une valeur à chaque \texttt{IntVar} de la matrice. S'il existe une solution, il envoie une matrice d'entiers à une fonction d'affichage.

\subsection{Interface Homme-Machine}
\label{ihmimpl}

Pour créer cette interface, nous avons utilisé majoritairement la bibliothèque Java Swing et un peu Java Awt (Swing s’appuyant sur Awt) en utilisant donc, ses modules graphiques mais aussi ceux qui permettent de répondre aux actions de l’utilisateur, soit ceux qui impliquent de la programmation événementielle.

\subsubsection{Visualisation des Données}

Pour créer et afficher la liste des UEs présentes dans le programme, la fenêtre principale prend l’instance de la classe \texttt{Configuration} qui contient toutes les informations du programme et explore chaque UE puis les séances à l’intérieur de celles-ci pour finir avec les contraintes portant sur les séances en créant, à chaque fois, un noeud dans un \texttt{JTree}\footnote{widget représentant un arbre dans \texttt{Jawa.Swing}}. Cet arbre est particulièrement adapté pour conserver la hiérarchie des données du programme (en jouant sur la profondeur des noeuds). La fenêtre de groupe suit le même procédé pour afficher la liste des groupes de base.

La fenêtre qui apparaît pendant la génération de l’emploi du temps est actualisée grâce à la génération de l’emploi du temps elle-même qui définit le texte qu’elle contient grâce aux méthodes void \texttt{addTextLn()} et void \texttt{clearText()} et définit aussi la progression ce qui change l’état de la barre de progression (\texttt{JProgressBar}) grâce à la méthode void \texttt{setProgression(int percentage)}.
Le manuel est ouvert par une simple fonction de la bibliothèque Java qui permet d’ouvrir un document externe avec le logiciel par défaut de l'utilisateur.

\subsubsection{Manipulation des Données via l'IHM}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{explicationfenetreprincipale}
    \caption{\label{homewindow} Fenêtre d'accueil}
\end{figure}

%La création de nouveaux éléments se fait à travers les boutons “Ajouter une UE”, “Ajouter une contrainte/préférence” et au bouton “Ajouter” de la fenêtre des groupes. Mais avant d’ajouter l’élément correspondant le programme effectue une série de vérification pour vérifier la cohérence des données entrées ainsi on ne peut avoir une UE qui ne contient strictement aucun cours ou encore deux contraintes qui s’opposerait complètement.

%Lorsque l’utilisateur clique sur “modifier la sélection”. Le programme récupère le niveau de l’élément sélectionné dans la hiérarchie et récupère l’élément si celui-ci est une contrainte ou une UE (sinon celui-ci est une séance ou la racine et ne peut être modifiée par cette méthode). Après ça, la fenêtre correspondant à l’UE ou à la contrainte s’ouvre, c’est la même fenêtre que la fenêtre de création d’UE ou de contrainte excepté le fait que les champs sont déjà remplis conformément à l’instance en cours de modification. Une fenêtre ouverte de cette manière ne créera donc pas une nouvelle UE mais la modifiera ainsi toutes les séances ne sont pas forcément régénérées et les contraintes qui y étaient associées ne sont pas perdus. Contrairement à la fenêtre des contraintes qui recrée une contrainte car cela n’a pas d’incidence sur les autres données du programme. 

%Le bouton de suppression récupère également le niveau de chaque élément sélectionné dans l’arbre pour savoir si celui-ci n’est pas une séance notamment. Dans le cas où celui-ci n’est pas une séance on le supprime de \texttt{Configuration} et graphiquement dans l’arbre. Il permet de supprimer plusieurs éléments en même temps si la sélection est multiple.

%De même la fenêtre des groupes permet de modifier les groupes de base (les ajouter, modifier et supprimer graphiquement et dans l’instance de \texttt{Configuration}). 
%Toutes ces modifications peuvent être effectués grâce à l’instance de \texttt{Configuration} contenue dans \texttt{HomeWindow} (fenêtre d’accueil) et à ses accesseurs en lecture et en écriture.
Le système de fenêtre effectue à chaque modification un ensemble de contrôle permettant de vérifier la cohérence des informations entrées par l'utilisateur (vérification que les champs ne sont pas vides, pour une UE : qu'il y ait au moins un groupe de sélectionné, etc).

Les boutons de modification et de suppression récupèrent le niveau de l'élément sélectionné dans le \texttt{JTree} pour déterminer la nature de celui-ci et modifier les données en conséquence.

Le bouton de sauvegarde est grisé quand il n’y a pas eu d’appel à la méthode void \texttt{dataChanged()} (pas de données modifiées depuis la dernière sauvegarde). Quand l’utilisateur clique sur ce bouton (et qu’il n’est pas grisé), les données sont sauvegardées sur le disque dur de l’utilisateur et plus précisément sur le fichier \hyperref[save]{« save.txt »}.


\subsubsection{Affichage de la Solution}

\begin{figure}[h]
    \label{schéma}  
    \centering
    \includegraphics[width=0.8\textwidth]{sortiehtml}
    \caption{Schéma d'écriture du fichier html}
\end{figure}

Pour créer notre page web, nous avons écrit un fichier HTML contenant notre emploi du temps par l'intermédiaire d'un programme en Java, en écrivant les balises \texttt{<style>} et \texttt{<script>} ainsi que le corps de notre emploi du temps. Voici un bref aperçu du codage d'une séance dans un tableau.
\newpage
\begin{verbatim}
<table>
    <tr>
        ...
        <td class="HLIN403">HLIN403-CM</td>
        ...
    </tr>
    ...
</table>
\end{verbatim}
Nous avons également deux boutons qui sont utilisés pour la modification des tableaux. Un bouton « Supprimer » et un bouton « Modifier/Ajouter ». Les CMI étant un cas particulier, nous avons décidé de rajouter dans chaque tableau trois lignes spécialement dédiées aux CMI pour que l'utilisateur puisse plus facilement gérer leurs séances. 

\begin{figure}[h]
    \label{EDT}
    \centering  
    \includegraphics[width=1\textwidth]{EDT} 
    \caption{Emploi du temps final}
\end{figure}

\section{Avancement}

L'utilisation de Java nous a permis de créer facilement des classes représentant les objets dont nous avions besoin grâce aux nombreuses propriétés que l'on peut fournir à un objet (attributs et méthodes). Cela nous a aussi permis de sauvegarder les données de manière cohérente et pratique. Aussi, nous avons créé des accesseurs permettant l'accès rapide à chacune des données nécessaires au solveur de contraintes et à l'interface.

De plus, grâce à la bibliothèque graphique Java Swing, nous avons été en mesure de produire une interface cohérente permettant à l’utilisateur de modifier les données du programme afin de construire un emploi du temps adapté à ses besoins. En plus de cela, le système vérifie la cohérence des données entrées afin de permettre au programme de fonctionner correctement. 
Ensuite, grâce à l'organisation des informations, leur récupération pour les exploiter afin d'établir le modèle de contraintes n'a pas été un souci. La mise en place d'un modèle qui permet de gérer des contraintes entre les séances mais aussi celles qui sont globales pour l'emploi du temps a été réalisée avec succès. La partie qui demanda le plus de temps est d'apprendre et d'utiliser une nouvelle forme de programmation, la programmation par contraintes. Mais, en définitive, toutes les contraintes nécessaires (voir annexe \autoref{listContraintes}) ont été codées et fonctionnent.

Finalement, nous obtenons un emploi du temps scindé en cinq tableaux, un par jour de la semaine. Ce dernier nous affiche dans chaque ligne l'emploi du temps pour un groupe. Nous avons aussi mis à disposition une aide qui explique comment manipuler cet emploi du temps et deux boutons servant à le modifier.

\subsection{Perspectives}

Tout d'abord, nous gérons les données de manière fonctionnelle, mais nous nous sommes rendus compte après le cours sur l'héritage en Java (pendant l'UE « Modélisation et programmation par objet 1 ») que nous aurions pu améliorer la gestion des différentes contraintes en utilisant l'héritage. Ainsi, il aurait fallu faire une classe abstraite \texttt{Contrainte.java} puis deux sous-classes : une pour les contraintes de type \texttt{Voulu} et \texttt{NonVoulu} qui possède exactement les mêmes attributs et une seconde pour les autres types qui possède une liste de séances en plus mais aucun créneau horaire.

Aussi, l'interface est fonctionnelle mais pourrait être améliorée notamment en modifiant l’aspect visuelle des fenêtres « Contrainte » et  « UE ». Par manque de temps, nous n’avons pas pu vérifier comment faire pour empêcher le programme d’être lancé plusieurs fois ce qui pourrait être gênant pour la sauvegarde qui serait écrasée par chaque instance du programme. Nous pourrions également proposer à l’utilisateur de choisir l’emplacement de l’enregistrement du fichier de sauvegarde ou encore quelle sauvegarde il souhaite utiliser. Il faudrait pour cela apporter une amélioration à notre programme qui serait la vérification de l’intégrité du fichier de sauvegarde.

En ce qui concerne la gestion des contraintes, les perspectives sont d'optimiser le système mis en place. Effectivement, les méthodes utilisées sont souvent mal choisies car nous n'avons suivi aucun cours officiel de programmation par contraintes, et cela engendre parfois une grande complexité dans l'algorithme qui ralentit fortement la résolution.

Finalement, pour la sortie de l’emploi du temps, nous pourrions améliorer son rendu général, ainsi que créer un bouton « Ajout Ligne » qui rajouterait une ligne à chaque emploi du temps, et qui remplacerait les trois lignes réservées aux CMI qui ne sont pas forcément nécessaires. 

\newpage
\section{Conclusion}

Nous avons eu du 16 janvier 2017 au 28 avril 2017 pour imaginer et concevoir un gestionnaire d'emploi du temps d'une semaine type à la Faculté des Sciences de Montpellier. Nous avons développé une interface intuitive pour exploiter au mieux toutes les fonctionnalités créées dans le but de produire automatiquement un emploi du temps sur mesure. Une grande partie de notre travail s'est focalisé sur l'organisation des informations, notamment à partir des diagrammes UML. Ce travail nous a donné la possibilité de sauvegarder les attentes de l'utilisateur, et par la suite de les récupérer pour pouvoir les traduire en un modèle de contraintes. La découverte et l'utilisation de la librairie \texttt{Choco} nous a, par ailleurs, été d'une grande aide pour pouvoir optimiser la génération d'un emploi du temps. Outre cette faculté du programme, nous avons également combiné la génération automatique à la modification manuelle via une page HTML. Aujourd'hui, ce gestionnaire offre une grande diversité d'options dans le cadre de l'organisation d'un emploi du temps universitaire, et permet de gérer au mieux les attentes des responsables d'UE, comme celle des étudiants.

Ce premier projet nous a permis de mieux appréhender l'univers de la gestion de projet. En consacrant exclusivement le premier mois de notre projet à la recherche et au travail en commun, nous avons pu rapidement l'organiser en quatre points, et répartir ainsi les tâches facilement entre les membres du groupe. L'étude du Java et de l'UML durant le semestre puis l'approfondissement de ceux-ci dans le cadre du projet ont considérablement élargi nos connaissances dans ce domaine. À plusieurs reprises, nous avons modifié notre travail grâce aux nouvelles connaissances acquises en cours afin de le parfaire. C'était un travail intéressant et nous ressortons confiants de cette expérience. Pour finir, la découverte de nouveaux langages tels que la programmation par contraintes, que nous étudierons en Master, ou encore la programmation évènementielle (pour l'IHM) nous a offert des connaissances personnelles non négligeables.
\newpage
\section{Remerciements}

Nous tenons à remercier Mme Bouziane pour l'aide qu'elle nous a apportée tout au long du projet, ainsi que M. Bourreau pour son temps et ses explications sur la programmation par contraintes qui nous ont été d'une grande aide. 

\newpage
\section{Annexes}

\subsection{Choco}
\label{Choco}
Choco est une bibliothèque Java Open Source dédiée à la programmation par contraintes.
Il permet à l'utilisateur de modéliser son problème.
Pour la résolutions d'un problème, choco s'appuie sur une stratégie de filtrage. Il étudie toute les contraintes pour assigner des valeurs aux variables dans le but d'optimiser l'objectif qui lui est fixé.
\\

 \href{http://www.Choco-solver.org/}{Vous pouvez trouver le lien vers le site de choco ici : http://www.Choco-solver.org/}
 \\
 
 \href{http://www.Choco-solver.org/apidocs/index.html}{Trouvez ici le lien vers la Javadoc de Choco et toutes leur méthodes : http://www.Choco-solver.org/apidocs/index.html}
\subsection{Liste des contraintes}
\label{listContraintes}

\begin{itemize}[label=\ding{220}]
    \item Par défaut dans Octempos
    \begin{itemize}[label=\textbullet]
        \item Chaque créneau de l'emploi du temps possède ou non une seule séance.
        \item Un même groupe ne peut avoir plusieurs fois la même séance dans son emploi du temps.
        \item Toutes les séances contenant au moins un groupe seront représentées dans l'emploi du temps.
        \item Une séance suivie par plusieurs groupes est au même créneau pour tous les groupes.
        \item Un groupe ne peut avoir cours à 8h et 18h30 dans une même journée.
        \item Un groupe ne peut avoir cours à 11h30 et 13h15 dans une même journée.
        \item Un groupe ne peut avoir un trou de plus de 3 heures (deux séances vides).
    \end{itemize}
    \item Pour les attentes de l'utilisateur
    \begin{itemize}[label=\textbullet]
        \item Une séance respecte les obligations des créneaux indiqués.
        \item Une séance respecte les interdictions des créneaux indiqués.
        \item Une séance ne peut être au même créneau que d'autres séances si elle est indiquée par l'utilisateur, contrainte \texttt{Diff}.
        \item Deux séances qui doivent se suivre (fait indiqué par l'utilisateur) ne doivent pas être sur deux jours différents (donc : séance1 à 18h30 et séance2 à 8h le lendemain).
    \end{itemize}
    \item Pour les préférences
    \begin{itemize}[label=\textbullet]
        \item Un groupe ne peut avoir un seul cours au cours d'une journée (par défaut).
        \item Une séance est au même créneau que d'autres séances si elle est indiquée par l'utilisateur, contrainte \texttt{Eq}.
        \item Une séance doit être directement suivie d'une autre séance si l'utilisateur l'a voulu, contrainte \texttt{Suivi}.
    \end{itemize}
\end{itemize}


\newpage
\subsection{Représentation du fichier de sauvegarde}
\label{save}
Voici un extrait du fichier de sauvegarde montrant la représentation d'une UE avec deux séances :

\begin{verbatim}
    Groupe=A
        Sous-groupe=A.1
        Sous-groupe=A.2
    Groupe=B
        Sous-groupe=B.1
        Sous-groupe=B.2
    UE=HLIN401
        Nom=Montet 
        Prenom=Olivier
        Total=0
        NombreCM=1
        NombreTD=1
        NombreTP=1
        Foreground=-13434880
        Background=-16711681
        GroupeUE=A
        GroupeUE=B
        PartageCM=TOUS
        PartageTD=GROUPE
        PartageTP=DEMIGROUPE
        Seance=CM1
            TypeSeance=CM
            GroupeSeance=A
            GroupeSeance=B
            Voulu=Vendredi:H2
            Equi=TD1
        Seance=TD1
            ...
\end{verbatim}

\newpage
\subsection{Diagramme de Classe}

\begin{figure}[h]
    \centering
    \label{diagrammeclasse}
    \includegraphics[width=\textwidth]{diagrammeclasse}
    \caption{Le diagramme de classe simplifié de Octempos}
\end{figure}



\end{document}
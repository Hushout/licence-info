#lang scheme

;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////////// Annexe //////////////////////////////////
;/////////////////////////////////////////////////////////////////////////////


(define binList->number-add
  (lambda (L taille add)
    (if (= taille 0)
        add
        (binList->number-add (cdr L) (- taille 1) (+ add (* (car L) (puiss 2 (- taille 1))))))))

(define binList->number
  (lambda (L)
    (binList->number-add L (length L) 0)))

(define number->binList
  (lambda (n)
    (if (or (= n 1) (= n 0)) (list n) (append (number->binList (floor (/ n 2))) (list (modulo n 2))))))

(define addZeros
  (lambda (nb L)
    (if (= 0 nb) L (cons 0 (addZeros (- nb 1) L)))))

(define bin-format
  (lambda (bin binLength bitNumber)
    (cond ((= bitNumber binLength) bin)
          ((> bitNumber binLength) (addZeros (- bitNumber binLength) bin))
          (else (bin-format (cdr bin) (- binLength 1) bitNumber)))))

(define plusUnBin
  (lambda (L)
    (letrec ((longueurL (length L))
             (bin (number->binList (+ (binList->number-add L longueurL 0) 1))))
      (bin-format bin (length bin) longueurL))))

;Transforme (a b c) (0 1 0) -> ((a . 0) (b . 1) (c . 0))

(define queDesUn?
  (lambda (L)
    (andmap (lambda (n) (= n 1)) L)))

(define toutAZero
  (lambda (L)
    (map (lambda (n) 0) L)))

(define bin->int
  (lambda (LS LB)
    (map cons LS LB)))

(define ensInt-bin
  (lambda (LS LB)
    (if (queDesUn? LB) (list (bin->int LS LB)) (append (list (bin->int LS LB)) (ensInt-bin LS (plusUnBin LB))))))

(define ensInt
  (lambda (L)
    (ensInt-bin L (toutAZero L))))

(define testInt
  (lambda (L)
    (if (ensInt L) #t #f))) 

    
;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD3 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////

;Ex1:

;a) -20

;b) 100

;c) 14

;Ex2:

;((lambda (a b c) (* c (- a b))) 2 (* 2 2) 10)

;((lambda ( a  b) (* a b)) 2 ((lambda (a b) (- a b))))

;Ex3:

;(define a 10)

;(let ((x a)) (* 2x)) -> 20

;(let ((a a )) (* 2 a)) -> 20

;(let ((a (* 3 a ))) (* 2 a )) -> 40

;(let ((a (* 2 a)) (b 5) (c (+ 1 a))) (+ a b c)) -> 36

;Ex4:

;l'expression affiche :

;a : b
;b : 3
;a : 4
;b : b

;Ex5:

;(define a 10) -> 10

;(let ((a 3) (b a)) (* a b)) -> 20

;(let* ((a 2 (b a))) (* a b)) -> 4

;(let* ((a (* 2 a )) (b 5) (c (+ 1 a))) (+ a b c)) -> 46

;(letrec ((a (* 2 a)) (b 5) (c (+ 1 a))) (+ a b c)) -> Erreur

;(let ((x 5)) (let* ((y (+ x 10)) (z (* x y))) (+ x y z))) -> 95


;Ex6:

;(define a 10) -> 10

;(define (foo x) (* a x)) -> (* 10 x)

;(let ((a 0)) (foo 5)) -> 50

;(define a 100) -> 100

;(let ((a 0)) (foo 5)) -> 500

;((lambda (a) (let ((a 1) (foo (lambda (x) (+ a x)))) (foo a))) 5) -> 6

;((lambda (a) (let* ((a 1) (foo (lambda (x) (+ a x)))) (foo a))) 5) -> 2



;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD4 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////



;Ex1:

(define somme-carres 
  (lambda (n)
    (if (= n 0) 0 ( + (* n n) (somme-carres (- n 1))))))

;Ex2:

(define puissance
  (lambda (n k)
    (if (= k 0) 1 (* n (puissance n (- k 1))))))


;Ex3:

;1)

(define somme-prix
  (lambda (n)
    (if (= n 0) 0 (+ (puiss (- n 1) 2) (somme-prix (- n 1))))))

;2)

(define gain-jour
  (lambda (n)
    (abs (- 300000 (somme-prix n)))))

;Ex4:


;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD5 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////



;Ex1:

;1) non, c'est une paire d'elements.

;2) non, c'est une liste.

;3) non, la liste vide n'est pas une paire.


;Ex2:

;(5 (((6 7 9 'r))) 8 12) -> bon

;(9 (((8 4 5 (4) 25) 3) 7) -> mauvais

;(() ()) -> bon

;(56 'p ('K 6) 8 (() (7 6 2))) -> bon


;Ex3:

;(car (2)) -> 2 & (cdr (2)) -> ()

;(car ()) -> erreur & (cdr ()) -> erreur

;(car ((1 2) 3 4)) -> (1 2) & (cdr ((1 2) 3 4)) -> (3 4)

;(car (() ())) -> () & (cdr (() ())) -> (())

;(car (1 (2 (3 4 5) 6) 7)) -> 1 & (cdr (1 (2 (3 4 5) 6) 7)) -> (2 (3 4 5) 6) 7)

;(car (((8 4) 6 (5 4)) (7 8 9))) -> ((8 4) 6 (5 4)) & (cdr (((8 4) 6 (5 4)) (7 8 9))) -> ((7 8 9))


;Ex4:

;1) erreur

;2) (+ (2 6) 10)

;3) 5

;4) 7

;5) (9)

;6) (5)

;7) ((a b) c d)

;8) (7 e f)

;9) (a b c d)

;10) (a)

;11) (a b c)

;12) nope


;Ex5:

;1) a = (+ (* (+ 2 6) 3) (+ 1 3))

;2) (cdr a) -> ((* (+ 2 6) 3) (+ 1 3))

;3) (cdadr a) -> ((+ 2 6) 3)


;Ex6:

(define premdeux?
  (lambda (e L)
    (if (empty? L) #f 
        (if (equal? (car L) e) #t
            (if (empty? (cdr L)) #f (equal? (cadr L) e))))))


;Ex7:

;(cons '(a b) '(c d)) -> ((a b) c d)

;(list '(a b) '(c d)) -> ((a b) (c d))

;(append '(a b) '(c d)) -> (a b c d)


;Ex8:

;1) (a b 5 a)

;6) 14


;Ex9:

(define longueur
  (lambda (L)
         (if (empty? L) 0 (+ 1 (longueur (cdr L))))))


;Ex10:

(define doubleSans
  (lambda (L)
    (if (empty? L) '() (cons (* (car L) 2) (doubleSans (cdr L))))))

(define doubleAvec
  (lambda (L)
    (map (lambda (n) (* n 2)) L)))



;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD6 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////


;Ex1:

;>(fact 5)
; >(fact 4)
;  >(fact 3)
;   >(fact 2)
;    >(fact 1)
;     >(fact 0)
;     >1
;    >1
;   >2
;  >6
; >24
;>120

;Ex2:

;>(fact-iter 5)
; >(fact 5 1)
;  >(fact 4 5)
;   >(fact 3 20)
;    >(fact 2 60)
;     >(fact 1 120)
;      >(fact 0 120)
;      >120

;Ex3:

(define sum-square-1-n
  (lambda (n)
    (if (= n 0) 0 (+ (* n n) (sum-square-1-n (- n 1))))))

(define sum-square-1-n-iter
  (lambda (n acc)
    (if (= n 0) acc (sum-square-1-n-iter (- n 1) (+ acc (* n n))))))

;Ex4:

(define inverse-rec
  (lambda (L)
    (if (null? L) '() (append (inverse-rec (cdr L)) (list (car L))))))

(define inverse-acc
  (lambda (L acc)
    (if (null? L) acc (inverse-acc (cdr L) (append (list (car L)) acc)))))

;Ex5:

(define sommeListe
  (lambda (L acc)
    (if (null? L) acc (sommeListe (cdr L) (+ acc (car L))))))

;Ex6:

(define sommerangimpair
  (lambda (L acc)
    (cond ((null? L) acc)
          ((null? (cdr L)) (+ acc (car L)))
          (else (sommerangimpair (cddr L) (+ acc (car L)))))))

;Ex7:

(define appartient?
  (lambda (e L)
    (cond ((null? L) #f)
          ((eq? e (car L)) #t )
          (else (appartient? e (cdr L))))))

;Ex8:

(define debut-acc
  (lambda (L n acc)
    (if (or (null? L) (= n 0)) acc (debut-acc (cdr L) (- n 1) (append acc (list (car L)))))))

(define debut
  (lambda (L n)
    (debut-acc L n '())))



;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD7 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////



;Ex1:

(define make-complexe
  (lambda (a b)
    (list a b)))

(define pre
  (lambda (C)
    (car C)))

(define pim
  (lambda (C)
    (cadr C)))

(define reel?
  (lambda (C)
    (= ( pim C) 0)))

(define complexe?
  (lambda (C)
    (= (pre C) 0)))

;Ex2:

(define somme-complexe
  (lambda (C1 C2)
    (make-complexe (+ (pre C1) (pre C2)) 
                   (+ (pim C1) (pim C2)))))

(define produit-complexe
  (lambda (C1 C2)
    (make-complexe (- (* (pre C1) (pre C2)) 
                      (* (pim C1) (pim C2)))
                   (+ (* (pim C1) (pre C2))
                      (* (pre C1) (pim C2))))))

(define inverse-complexe
  (lambda (C)
    (make-complexe (/ (pre C) (+ (pre C) (pre C))
                      (* (pim C) (pim C)))
                   (/ (- 0 (pim C)) (+ (* (pre C) (pre C))
                                               (* (pim C) (pim C)))))))

(define divise-complexe
  (lambda (C d)
    (produit-complexe C (inverse-complexe d))))

;Ex3:

(define puiss-complexe
  (lambda (C k)
    (if (= 0 k) 
        (make-complexe 1 0) 
        (if (> k 0) 
            (produit-complexe C (puiss-complexe C (- k 1)))
            (puiss-complexe (inverse-complexe C) (- 0 k))))))
				

;Ex4:

;1)

(define monome
  (lambda (deg coef)
    (if (= deg 0) (list coef) (cons 0 (monome (- deg 1) coef)))))

;2)
	
(define addpoly
  (lambda (p1 p2)
    (cond ((null? p1) p2)
          ((null? p2) p1)
          (else (cons (+ (car p1) (car p2)) 
                      (addpoly (cdr p1) (cdr p2)))))))

;3)

(define multconst
  (lambda (p c)
    (map (lambda (n) (* n c)) p)))

;4)

(define multvar
  (lambda (p)	
    (cons 0 p)))

;5)

(define puiss-add
  (lambda (n k add)
    (if (= 0 k) add (puiss-add n (- k 1) (* add n)))))

(define puiss
  (lambda (n k)
    (puiss-add n k 1)))

(define evalpoly-inc
  (lambda (p v inc)
    (if (null? p) 
        0 
        (+ (* (puiss (car p) inc) v) (evalpoly-inc (cdr p) v (+ inc 1))))))
					
(define evalpoly
  (lambda (p v)
    (if (null? p) 0 (+ (car p) (* v (evalpoly (cdr p) v))))))	

;Ex5:

;1)

(define monome->string
  (lambda (coef deg)
    (cond ((or (= coef 0) (= deg 0)) (number->string coef))
          (else (string-append (number->string coef) "^" (number->string deg))))))

;2)

(define polynome->string
  (lambda (p i)
    (cond ((null? p) "")
          ((null? (cdr p)) (monome->string (car p) i))
          (else (string-append (monome->string (car p) i)
                               " + " (polynome->string (cdr p) (+ i 1)))))))

;/////////////////////////////////////////////////////////////////////////////
;/////////////////////////////// HLIN403 - TD8 ///////////////////////////////
;/////////////////////////////////////////////////////////////////////////////



(define rendreMonnaie
  (lambda (somme nbSortesPieces valeurPiece)
    (letrec ((rendre (lambda (somme n)
                       (cond ((= somme 0) 1)
                             ((or (< somme 0) (= n 0)) 0)
                             (#t (+ (rendre somme (- n 1)) (rendre (- somme (valeurPiece n)) n)))))))
      (rendre somme nbSortesPieces))))

(define valeurPiecesEuro
  (lambda (piece)
    (cond ((= piece 1) 1)
          ((= piece 2) 2)
          ((= piece 3) 5)
          ((= piece 4) 10)
          ((= piece 5) 20)
          ((= piece 6) 50)
          ((= piece 7) 100)
          ((= piece 8) 200))))

(define rendreEuro
  (lambda (somme)
    (rendreMonnaie somme 8 valeurPiecesEuro)))


;Ex1:

(define rendreMonnaieList
  (lambda (somme nbSortesPieces valeurPiece)
    (letrec ((rendre (lambda (somme n L)
                       (cond ((= somme 0) (list L))
                             ((or (< somme 0) (= n 0)) '())
                             (#t (append (rendre somme (- n 1) L) (rendre (- somme (valeurPiece n)) n (cons (valeurPiece n) L))))))))
      (rendre somme nbSortesPieces '()))))

(define rendreEuroList
  (lambda (somme)
    (rendreMonnaieList somme 8 valeurPiecesEuro)))

;Ex2:

;Les noeuds seront représenter par un liste composé d'un entier et d'un string pour la couleur.

;Ex3:

;//////////////////////// Consante

(define noir #t)
(define rouge #f)

;//////////////////////// Constructeur

(define make-noeud
  (lambda (int col)
    (cons int col)))

;//////////////////////// Accesseurs

(define get-noeud-int
  (lambda (node)
    (car node)))

(define get-noeud-col
  (lambda (node)
    (cdr node)))

;//////////////////////// Predicat

(define noir?
  (lambda (node)
    (get-noeud-col node)))

(define pair?
  (lambda (node)
    (= (modulo (get-noeud-int node) 2) 0)))

(define noeud-test (make-noeud 14 noir))

;Ex4:

;//////////////////////// Consante

(define empty-arn '())

;//////////////////////// Constructeur

(define make-arn
  (lambda (root left right)
    (list root left right)))

;//////////////////////// Accesseurs

(define get-root-arn
  (lambda (arn)
    (car arn)))

(define get-left-arn
  (lambda (arn)
    (cadr arn)))

(define get-right-arn
  (lambda (arn)
    (caddr arn)))

;//////////////////////// Predicats
    
(define empty-arn?
  (lambda (arn)
    (eq? arn empty-arn)))

(define leaf-arn?
  (lambda (arn)
    (and (not (empty-arn? arn)) (empty-arn? (get-left-arn arn)) (empty-arn? (get-right-arn arn)))))

;Ex4:

(define goodColor
  (lambda (node)
    (if (pair? node) (make-noeud 2 #t) #t)))

(define pairARN
  (lambda (arn)
    (cond ((empty-arn? arn) '())
          ((leaf-arn? arn) '()))))









        
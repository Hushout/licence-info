Object subclass: #Bonbon	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!Bonbon subclass: #Carambar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!Object subclass: #Compteur	instanceVariableNames: 'valeur'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!Compteur methodsFor: 'initialize - release' stamp: 'cd 12/8/2015 10:22'!initialize	val := 0! !!Compteur methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 09:06'!setVal: anInteger	valeur := anInteger.! !!Compteur methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 09:04'!getVal	^valeur! !!Compteur methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 09:08'!main	| c |	c := Compteur new.	c setVal: 33.	^c getVal	! !!Compteur methodsFor: 'metier' stamp: 'cd 3/20/2015 09:25'!raz	valeur := 0.	! !!Compteur methodsFor: 'metier' stamp: 'cd 4/7/2016 22:01'!decr	val := val - 1.	^self! !!Compteur methodsFor: 'metier' stamp: 'cd 12/8/2015 10:25'!incr	val := val + 1.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Compteur class	instanceVariableNames: 'soleInstance'!!Compteur class methodsFor: 'as yet unclassified' stamp: 'cd 12/8/2015 10:34'!test	"pour tester cette classe exécuter l'instruction ci-dessous"	"self test"	^self new incr incr incr getVal! !!Compteur class methodsFor: 'as yet unclassified' stamp: 'cd 4/7/2016 22:06'!newSingleton	soleInstance isNil		ifTrue: [ soleInstance := super new ]		ifFalse: [Transcript show: 'this is singleton, returning the unique instance'; cr].	^ soleInstance! !!Compteur class methodsFor: 'as yet unclassified' stamp: 'cd 12/8/2015 12:11'!new	soleInstance isNil		ifTrue: [ soleInstance := super new ]		ifFalse: [Transcript show: 'this is singleton, returning the unique instance'; cr].	^ soleInstance! !Object subclass: #Distrib	instanceVariableNames: 'colonnes'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!Distrib methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 11:09'!remplir: numeroCol avec: typeBonbon	| unePile |		(typeBonbon inheritsFrom: Bonbon)		ifFalse: [ self error: 'Ce distributeur doit contenir des bonbons' ]		ifTrue: [ 			unePile := (colonnes at: numeroCol).			[unePile isFull] whileFalse: 				[ unePile push: (typeBonbon new)]			]! !!Distrib methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 10:51'!initialize: taille	"le distributeur est représenté par un tableau de 2 cases, chaque case contient une pile de taille 'taille'. Toutes les piles ont la même taille."	"Nécessite que la méthode de classe new: soit définie sur la classe Pile."		colonnes := Array new: 2.	1 to: 2 do: [ :i | 		colonnes at: i put: (Pile new: taille) ]! !!Distrib methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 12:14'!donner: numeroCol 	| unePile |	unePile := (colonnes at: numeroCol).		(unePile isEmpty)			ifFalse: [ ^unePile pop]			ifTrue: [ self error: 				'Il n''y a plus de bonbons dans la colonne ' , 				numeroCol asString , 				' du distributeur']! !Object subclass: #Generateur	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Generateur class	instanceVariableNames: ''!!Generateur class methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 12:42'!getCpt	| x |	x := 0.	^[x := x + 1]! !Bonbon subclass: #Mistral	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!Pile commentStamp: 'cd 3/8/2017 10:34' prior: 0!Implantation d'une pile en utilisant une collection ordonnée.Internal Representation and Key Implementation Points.    Instance Variables	contenu:		<Collection>	index:		<Integer>	taille:		<Integer>    Implementation Points!!Pile methodsFor: 'gestion de pile' stamp: 'cd 3/15/2017 10:30'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Impossible de dépiler d''une pile vide' ]! !!Pile methodsFor: 'gestion de pile' stamp: 'cd 3/8/2017 11:50'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Pas de sommet pour une pile vide' ]! !!Pile methodsFor: 'gestion de pile' stamp: 'cd 3/8/2017 12:25'!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'initialization-release' stamp: 'cd 3/8/2017 12:27'!initialize: anInteger	"la pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = taille"	capacite := anInteger.	"le contenu est représenté par une collection ordonnée"	contenu := Array new: capacite.		self assert: (self isEmpty).	! !!Pile methodsFor: 'essai' stamp: 'cd 3/20/2015 11:23'!test	| p |	p := Pile new initialize: 5.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop! !!Pile methodsFor: 'as yet unclassified' stamp: 'cd 4/8/2016 12:24'!taille: n	^Pile new! !!Pile methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 11:04'!initialize	self initialize: 5.	! !!Pile methodsFor: 'as yet unclassified' stamp: 'cd 4/15/2016 10:37'!do: aBlock	"un itérateur pour la classe Pile"	buffer do: aBlock.					! !!Pile methodsFor: '*Tests-util' stamp: 'cd 3/8/2017 10:59'!isEmpty	^index = 0! !!Pile methodsFor: '*Tests-util' stamp: 'cd 3/26/2015 08:49'!size	^index! !!Pile methodsFor: '*Tests-util' stamp: 'cd 3/8/2017 12:27'!isFull	^index = capacite	! !!Pile methodsFor: 'printing' stamp: 'cd 3/15/2017 12:27'!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."		aStream nextPutAll: 'une Pile, de taille: '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant: '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu do: [ :each | each printOn: aStream. aStream space ].	aStream nextPut: $).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pile class	instanceVariableNames: ''!!Pile class methodsFor: 'instance initalization' stamp: 'cd 3/15/2017 10:48'!new: taille	"on pourrait écrire 'self new initialize'"	^(super new) initialize: taille! !!Pile class methodsFor: 'instance creation' stamp: 'cd 4/15/2016 10:02'!taille: n	"Question :que vaut self, Reponse: la classe à laquelle a été envoyé le message"	"donc la class Pile ou une de ses sous-classes"		^self new initialize: n! !!Pile class methodsFor: 'instance creation' stamp: 'cd 4/8/2016 12:38'!new	^ super new initialize! !Pile subclass: #PileTypee	instanceVariableNames: 'typeElements'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!PileTypee methodsFor: 'as yet unclassified' stamp: 'cd 4/15/2016 10:56'!initialize: n type: T	super initialize: n.	(T isKindOf:  ClassDescription)		ifTrue:[typeElements := T]		ifFalse: [ self error: T asString , 'n''est pas un type' ]! !!PileTypee methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 12:29'!taille: anInteger type: aClass	super initialize: anInteger.	typeElements := aClass.! !!PileTypee methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 12:37'!push: anObject	(anObject isKindOf: typeElements)		ifTrue: [ super push: anObject ]		ifFalse: [ self error: 			'Impossible d''empiler ' , 			anObject asString, 			' dans une pile typee de ' , 			typeElements asString]! !!PileTypee methodsFor: 'as yet unclassified' stamp: 'cd 4/3/2015 09:52'!de: type taille: t	typeElements := type.	super initialize: t.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PileTypee class	instanceVariableNames: ''!!PileTypee class methodsFor: 'as yet unclassified' stamp: 'cd 4/3/2015 09:49'!de: type taille: t	^super new de: type taille: t! !TestCase subclass: #TestDistrib	instanceVariableNames: 'unDistrib'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!TestDistrib methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 11:10'!testRemplir	unDistrib remplir: 1 avec: Carambar.	unDistrib remplir: 2 avec: Mistral.	"self assert: ..."	! !!TestDistrib methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 11:05'!setUp	unDistrib := Distrib new initialize: 5.	! !TestCase subclass: #TestPile	instanceVariableNames: 'standard pleine vide'	classVariableNames: ''	poolDictionaries: ''	category: 'HLIN603-67'!!TestPile methodsFor: 'initialization' stamp: 'cd 3/15/2017 10:26'!setUp	"une pile vide"	vide := Pile new initialize: 3.		"une pile standard ni vide ni pleine"	standard := Pile new initialize: 4.	standard push: 1.		"une pile pleine"	pleine := Pile new initialize: 2.	pleine push: 1.	pleine push: 2.! !!TestPile methodsFor: 'tests' stamp: 'cd 4/8/2016 10:54'!testPush2	piletest push: 22.	self assert: piletest top equals: 11.	! !!TestPile methodsFor: 'tests' stamp: 'cd 4/8/2016 10:32'!testFull	self assert: pilepleine isFull.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/8/2017 11:48'!testPush	standard push: 33.	self assert: (standard isEmpty not).	self assert: (standard top = 33).! !!TestPile methodsFor: 'tests' stamp: 'cd 4/8/2016 11:44'!testFaux	piletest truc.! !!TestPile methodsFor: 'tests' stamp: 'cd 4/8/2016 11:32'!testEmpty	self assert: pilevide isEmpty.! !!TestPile methodsFor: 'as yet unclassified' stamp: 'cd 3/15/2017 10:29'!testPop	| current r |	current := standard top.	standard push: #test.	r := standard pop.	self assert: (standard isFull not).	self assert: (r == #test).	self assert: (standard top == current).! !!TestPile methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 11:44'!testPleine	self assert: pleine isFull	! !!TestPile methodsFor: 'as yet unclassified' stamp: 'cd 3/8/2017 11:43'!testVide	self assert: vide isEmpty	! !